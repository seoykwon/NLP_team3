-- =========================================
-- 스키마: audit_finance (필요 시 이름 변경)
-- =========================================
CREATE SCHEMA IF NOT EXISTS audit_finance;
SET search_path = audit_finance, public;

-- =========================
-- 1) 차원 테이블 (메타데이터)
-- =========================

-- 회사(발행사)
CREATE TABLE IF NOT EXISTS dim_company (
  company_id   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  company_name TEXT NOT NULL,
  CONSTRAINT uq_company_name UNIQUE (company_name)
);

-- 계정(항목) 사전 + 계층
-- account_path 예: '유동자산_현금및현금성자산' (구분자: '_')
CREATE TABLE IF NOT EXISTS dim_account (
  account_id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  account_name      TEXT NOT NULL,          -- 표준 계정명 (leaf 또는 중간노드 모두 가능)
  statement_type    TEXT,                   -- 'BS' / 'PL' / 'CF' / ...
  account_path      TEXT NOT NULL,          -- 전체 경로 (구분자 '_')
  parent_account_id BIGINT REFERENCES dim_account(account_id) ON DELETE SET NULL,
  alias_json        JSONB  DEFAULT '{}'::jsonb,  -- 간단 별칭 매핑(정확 매칭/간단 정규화용)
  CONSTRAINT uq_account_name UNIQUE (account_name),
  CONSTRAINT uq_account_path UNIQUE (account_path)
);

-- (선택) 별칭 정규화 테이블: 좀 더 정교한 매핑/우선순위/정규식 지원
CREATE TABLE IF NOT EXISTS dim_account_alias (
  alias_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  account_id   BIGINT NOT NULL REFERENCES dim_account(account_id) ON DELETE CASCADE,
  alias_text   TEXT NOT NULL,               -- 원문 표기(정확매칭)
  regex        TEXT,                        -- 선택: 정규식 매칭 패턴
  priority     INT  DEFAULT 100,            -- 낮을수록 우선
  is_active    BOOLEAN DEFAULT TRUE,
  CONSTRAINT uq_alias_unique UNIQUE (account_id, alias_text)
);
CREATE INDEX IF NOT EXISTS idx_account_alias_text ON dim_account_alias (alias_text);
CREATE INDEX IF NOT EXISTS idx_account_alias_active ON dim_account_alias (is_active, priority);

-- 단위 (currency_code 제거)
CREATE TABLE IF NOT EXISTS dim_unit (
  unit_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  unit_name  TEXT NOT NULL,                -- 예: '백만원', '천원'
  CONSTRAINT uq_unit UNIQUE (unit_name)
);

-- 보고기간: anchor_year로 기준연도 명시 + 표 제목 아래의 start_date/end_date 저장
-- period_label: '당기','전기','전전기' 등 | period_order: 당기=0, 전기=1, 전전기=2 ...
CREATE TABLE IF NOT EXISTS dim_period (
  period_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  anchor_year   INT NOT NULL,              -- 보고서 기준년도(명시적)
  period_label  TEXT NOT NULL,
  period_order  INT  NOT NULL,
  start_date    DATE,                      -- 표 제목 또는 보고기간 시작일
  end_date      DATE,                      -- 표 제목 또는 보고기간 종료일
  CONSTRAINT uq_period UNIQUE (anchor_year, period_order)
);

-- 소스 파일(HTML/CSV) 메타
CREATE TABLE IF NOT EXISTS dim_source (
  source_id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  file_name      TEXT NOT NULL,
  file_path      TEXT,
  anchor_year    INT,                      -- 파일이 가리키는 기준년도(추정/해석)
  table_tag      TEXT,                     -- 원본 내 테이블 식별자(있으면)
  table_title    TEXT,                     -- 표 제목(여기서 start/end_date 힌트 추출)
  extracted_at   TIMESTAMPTZ DEFAULT now(),
  sha256         CHAR(64),
  parser_version TEXT
);
CREATE INDEX IF NOT EXISTS idx_source_anchor ON dim_source (anchor_year);

-- 섹션 카탈로그
CREATE TABLE IF NOT EXISTS dim_section (
  section_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  section_code  TEXT NOT NULL,        -- balance / income / cashflow / equity / comprehensive ...
  section_name  TEXT,
  section_order INT,
  CONSTRAINT uq_section_code UNIQUE (section_code)
);

-- =========================
-- 2) 사실 테이블 (롱포맷)
-- =========================
-- value_text(원문) 중심으로 저장하고, 숫자 파싱 성공 시 value_num 병행 저장
CREATE TABLE IF NOT EXISTS fact_financial (
  fact_id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  company_id     BIGINT NOT NULL REFERENCES dim_company(company_id) ON DELETE RESTRICT,
  account_id     BIGINT NOT NULL REFERENCES dim_account(account_id) ON DELETE RESTRICT,
  period_id      BIGINT NOT NULL REFERENCES dim_period(period_id)   ON DELETE RESTRICT,
  unit_id        BIGINT NOT NULL REFERENCES dim_unit(unit_id)       ON DELETE RESTRICT,
  source_id      BIGINT REFERENCES dim_source(source_id)            ON DELETE SET NULL,
  section_id     BIGINT REFERENCES dim_section(section_id)          ON DELETE SET NULL,

  row_no         INT,                   -- 원본 테이블 내 행 번호
  subject_id     TEXT,                  -- 셀/주제 식별자(헤더텍스트/id/xpath 등)

  value_text     TEXT,                  -- 원문 값(텍스트)
  value_num      NUMERIC(24,4),         -- 파싱 성공 시 숫자값
  consolidation  TEXT,                  -- 연결/별도
  gaap_basis     TEXT,                  -- IFRS/K-GAAP 등
  note_inline    TEXT,                  -- 셀 안의 간단 주석 텍스트(있다면)
  created_at     TIMESTAMPTZ DEFAULT now(),

  -- 숫자나 텍스트 최소 한쪽은 있어야 함
  CONSTRAINT ck_value_presence CHECK (value_num IS NOT NULL OR value_text IS NOT NULL),

  -- 중복 방지(섹션/소스/위치/주제 조합)
  CONSTRAINT uq_fact UNIQUE (
    company_id, account_id, period_id, unit_id,
    section_id, source_id, row_no, subject_id
  )
);

-- =========================
-- 3) 주석(각주) 본문 및 연결 (다대다)
-- =========================
-- 주석 본문(원문 번호와 텍스트를 보관)
CREATE TABLE IF NOT EXISTS dim_note (
  note_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  source_id   BIGINT REFERENCES dim_source(source_id) ON DELETE CASCADE,
  note_no     TEXT,        -- 예: '주1', '①', 'a', '1' 등 원문 표기 그대로
  note_text   TEXT NOT NULL,
  created_at  TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_note_source_no ON dim_note (source_id, note_no);

-- fact 셀과 주석의 다대다 연결
CREATE TABLE IF NOT EXISTS fact_note_map (
  fact_id  BIGINT NOT NULL REFERENCES fact_financial(fact_id) ON DELETE CASCADE,
  note_id  BIGINT NOT NULL REFERENCES dim_note(note_id)       ON DELETE CASCADE,
  PRIMARY KEY (fact_id, note_id)
);

-- =========================
-- 4) 규칙/검증 보조
-- =========================
CREATE TABLE IF NOT EXISTS rule_negative_policy (
  account_id     BIGINT NOT NULL REFERENCES dim_account(account_id) ON DELETE CASCADE,
  allow_negative BOOLEAN NOT NULL,
  CONSTRAINT pk_rule_negative PRIMARY KEY (account_id)
);

CREATE TABLE IF NOT EXISTS audit_issue (
  issue_id   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  source_id  BIGINT REFERENCES dim_source(source_id)  ON DELETE SET NULL,
  company_id BIGINT REFERENCES dim_company(company_id) ON DELETE SET NULL,
  period_id  BIGINT REFERENCES dim_period(period_id)   ON DELETE SET NULL,
  account_id BIGINT REFERENCES dim_account(account_id) ON DELETE SET NULL,
  severity   TEXT NOT NULL,      -- 'ERROR' / 'WARN' / 'INFO'
  issue_code TEXT NOT NULL,      -- 'NEG_FORBIDDEN','MISSING_VALUE','UNIT_UNKNOWN', ...
  details    TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- =========================
-- 5) 색인(쿼리 성능)
-- =========================
CREATE INDEX IF NOT EXISTS idx_fact_company_period   ON fact_financial (company_id, period_id);
CREATE INDEX IF NOT EXISTS idx_fact_company_account  ON fact_financial (company_id, account_id);
CREATE INDEX IF NOT EXISTS idx_fact_source           ON fact_financial (source_id);
CREATE INDEX IF NOT EXISTS idx_fact_section          ON fact_financial (section_id);
CREATE INDEX IF NOT EXISTS idx_fact_source_section   ON fact_financial (source_id, section_id);
CREATE INDEX IF NOT EXISTS idx_fact_position         ON fact_financial (section_id, row_no, subject_id);
CREATE INDEX IF NOT EXISTS idx_period_anchor_order   ON dim_period (anchor_year, period_order);

-- 계정 계층 탐색 보조(부모-자식)
CREATE INDEX IF NOT EXISTS idx_account_parent ON dim_account (parent_account_id);

-- alias_json GIN 인덱스(키/값 포함 검색)
CREATE INDEX IF NOT EXISTS idx_account_alias_gin ON dim_account USING GIN (alias_json);

-- =========================
-- 6) 뷰(예시)
-- =========================
CREATE OR REPLACE VIEW vw_financial_wide_example AS
SELECT
  c.company_name,
  p.anchor_year,
  MAX(CASE WHEN a.account_name = '유동자산'         THEN f.value_num END) AS 유동자산,
  MAX(CASE WHEN a.account_name = '현금및현금성자산' THEN f.value_num END) AS 현금및현금성자산,
  MAX(CASE WHEN a.account_name = '재고자산'         THEN f.value_num END) AS 재고자산
FROM fact_financial f
JOIN dim_company  c ON f.company_id = c.company_id
JOIN dim_account  a ON f.account_id = a.account_id
JOIN dim_period   p ON f.period_id  = p.period_id
GROUP BY c.company_name, p.anchor_year;

-- 초기 섹션 시드
INSERT INTO dim_section (section_code, section_name, section_order)
VALUES
  ('balance','재무상태표',1), ('income','손익계산서',2),
  ('cashflow','현금흐름표',3), ('equity','자본변동표',4),
  ('comprehensive','포괄손익계산서',5)
ON CONFLICT (section_code) DO NOTHING;

-- 1) 계정명에 걸린 전역 UNIQUE 제약 제거
ALTER TABLE audit_finance.dim_account
  DROP CONSTRAINT IF EXISTS uq_account_name;

-- (선택) 2) 같은 부모 아래에서만 이름 고유하도록 범위 제약 추가
--    (부모가 다르면 같은 이름 허용)
CREATE UNIQUE INDEX IF NOT EXISTS uq_account_scoped
  ON audit_finance.dim_account(parent_account_id, account_name);
